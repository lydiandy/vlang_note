### 变量

V是静态类型语言,每一个变量都有对应类型

#### 声明和赋值

V语言中只有唯一的一种变量声明和赋值方式 :=

并且声明和赋值是要同时的,这意味着变量总会有一个初始值

```v
a:=false
b:='abc'
c:=3   //默认推断为int
f:=3.1 //默认推断为f64
```

#### 类型推断

上述的代码并没有体现出变量的类型,是因为编译器会根据变量的值自动进行类型推断

#### 显示指定类型

如果不希望由编译器自动类型推断,可以通过T(value)的格式明确变量类型,T是类型,value是变量值

```v
x:=i64(3) //x是i64类型，而不是默认推断的int
y:=f32(3.0) //y是f32类型，而不是默认推断的f64
```

#### 判断变量类型

通过使用typeof内置函数,可以判断变量类型

```v
x:=3
s:='abc'
println(typeof(x)) //int
println(typeof(s)) //string
```

#### 默认不可变

跟rust一样,变量默认不可变,要声明为可变,使用mut关键字

```v
mut age := 20
println(age)
age = 21
println(age)
```

要注意区分:=和=的不同之处:

:=的含义是为变量声明并赋值

=的含义是为变量绑定一个新的值,也可以理解为修改变量值

变量声明后，如果没有被使用：

开发模式(v run)，编译器只是会警告，但是仍然继续编译,方便开发调试，而不用去临时注释掉

生产编译模式（-prod），编译器会报错，停止编译

以下几种情况的代码,会编译不通过:

```v
fn main() {
	age = 21 //变量还未声明
}
```

```v
fn main() {
	age := 21 //变量声明和赋值后,没有使用,非生产编译,只会警告,--prod生产编译时会不通过
}
```

```v
fn main() {
	a := 10
	if true {
		a := 20 //跟其他语言不一样,没有上级变量隐藏,在函数内部,同名的变量只能定义一个
	}
}
```

#### 多变量赋值

```v
fn main() {
	f1()
	f2()
	f3()
  f4()
}

fn f1() {
	a, b, c := 1, 3, 5 // 多变量声明并赋值
	println(a)
	println(b)
	println(c)
}

fn f2() {
	mut a := 1
	mut b := 2
	a, b = b, a // 交换
}

fn f3() {
	mut a := 11
	mut b := 22
	mut c := 33
	mut d := 44
	a, b, c, d = b, a++, d + 1, -c // 多变量赋值
	println(a) // 22
	println(b) // 11
	println(c) // 45
	println(d) // -33
}
fn f4() {
  mut a, mut b, mut c := 1, 2, 3 //多变量+可变赋值
	println(a)
	println(b)
	println(c)
}
```

条件赋值

```v
d, e, f := if true {
		1, 'awesome', [13]
	} else {
		0, 'bad', [0]
	}
```

匹配赋值

```v
a,b,c := match false {
		true { 1,2,3 }
		false { 4,5,6 }
		else { 7,8,9 }
	}
```



#### 强制类型转换

可以通过T( ) 对类型进行显示声明,或者强制类型转换

```v
module main

fn main() {
	x := int(3)
	y := byte(x)
	println('y is $y')
	z := f32(x)
	println('z is $z')
	f := 1.2
	i := int(f)
	println(i) // 输出1，强制转换丧失精度
}
```

#### 没有模块级变量/全局变量

跟其他语言比较不同的是,V语言中的变量只能在函数中定义,就是局部变量,

这意味着V语言中没有全局变量,没有模块级变量







